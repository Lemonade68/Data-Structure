//k叉树：每个父结点最多有k个子节点的树，    可以每个结点都只有一个子节点！！！


// 二叉树的性质：

// 性质1.在二叉树的第i层上至多有 2的i-1次方 个结点

// 性质2.深度为k的二叉树上至多含有 2的k次方-1 个结点
        // 证明：1+2+4+...+2的k-1次方

// 性质3.对于任意二叉树，若含有n个叶子结点，m个度为2的结点，则有n=m+1
        // 多一个度为2的结点相当于多出一条分支，也即叶子结点加1，类比分子式

// 满二叉树：   深度为k且含 2的k次方-1 个结点的二叉树
// 完全二叉树：树中所含n个结点和满二叉树中编号为1-n的结点一一对应

// 性质4.具有n个结点的完全二叉树的深度为 log2n向下取整+1（有小数部分就舍去小数部分）
        // 证明：由性质2：2的k-1次方 <= n < 2的k次方,两边同时取对数,然后取整

// 性质5.在完全二叉树中进行从1-n无漏的编号:
        // (1)若i=1,则该结点为二叉树的根，无双亲； 否则编号为i/2向下取整的结点为其双亲结点
        // (2)若2i>n,则该结点无左孩子； 否则编号为2i的结点为其左孩子
        // (3)若2i+1>n,则该结点无右孩子；  否则编号为2i+1的结点为其右孩子


// 二叉树的存储：

// 1.顺序存储:
#define MAX_TREE_SIZE 100       //二叉树最大结点数
typedef TreeElemType SqBiTree[MAX_TREE_SIZE] // 0号元素储存根结点（从0下标开始存储）
SqBiTree bt;

// 按照满二叉树的标号进行存储，  因此顺序存储对于完全二叉树而言较为适用（无缝隙），而对于非完全二叉树而言较为浪费空间


// 2.链式存储
// (1) 二叉链表
typedef struct BiTNode{
    TElemType data;
    struct BiTNode *lchild, *rchild;    //左右孩子指针
} BiTNode, *BiTree;


