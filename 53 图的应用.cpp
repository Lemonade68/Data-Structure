// 1.最小生成树

// 生成树: 图的所有顶点由边连在一起，且不存在回路  ---- 是图的极小连通子图
// 所有生成树中，使各边权值之和最小的称为最小生成树

// 两算法共性：都利用了MST性质

// 方法1：prim算法：  ----选择点
// 从u集合与vex-u集合中找一条最短的路径，之后将该路径中vex-u的顶点加入到u集合中，重复操作
// 先从一个顶点开始，与剩下所有顶点找最短的边，对应的顶点与该顶点和边并到一块之后作为整体  重复步骤

// 方法2：kruskal算法：   ----选择边
// 初始包括所有顶点，不断选取代价最小的边加入进去（不能形成环），重复直到图联通


// -------------------------------------------

// 2.最短路径
// 有向网A点到B点的权值之和最小的路径   （不一定包含n个顶点）

// 一、单源最短路径--Dijkstra算法
// 看作业


// 二、所有顶点间最短路径--Floyd算法
// 看ppt


// -------------------------------------------

// 有向无环图--无环的有向图   DAG
// AOV网：activity on vertex network    顶点：活动；弧：活动间优先制约关系；
// AOE网：activity on edge         弧：活动；顶点：活动开始或结束


// 3.拓扑排序     ---针对AOV网
// （直接）前驱、（直接）后继、不存在环

// 步骤：找一个没前驱的顶点输出，然后删除该顶点以及其发出的弧，重复操作
// 判断AOV网是否存在环：构造顶点拓扑排布后，若所有顶点都在序列中，则无环

// -------------------------------------------

// 4.关键路径     ---针对AOE网（工程计划）
// 源点：入度为0的点   工程开始
// 汇点：出度为0的点   工程结束
// 关键路径：路径长度最长的路径      路径长度：路径上各活动持续时间之和

// 理解：关键活动表示这些活动必须在紧凑进行下整个工程才能以最少的时间完成

// 事件vj最早发生时间  ve(vj)   vertex early
// 事件vj最晚发生时间  vl(vj)   vertex late
// 活动ai最早开始时间  e(ai)
// 活动ai最晚开始时间  l(ai)
// l(ai) - e(ai)称为完成活动ai的时间余量
// 关键活动：关键路径上的活动  时间余量为0

// 对于 j------>k    弧上标有ai，持续时间为w     有： 
// (1) e(ai) = e(j)
// (2) l(ai) = l(k) - w

// 求ve(j)和vl(j):
// ve(1) = 0开始往后递推   ve(j) = Max{ ve(i) + w_ij }  i指向j(i可能多个)
// vl(n) = ve(n)开始向前递推   vl(i) = Min{ vl(j) - w_ij }  i指向j(j可能多个)

// 求关键路径：  1.求ve(i),vl(j)    2.求e(i),l(i)    3.求l(i)-e(i)


